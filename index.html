<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>黄奕弟的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="黄奕弟的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黄奕弟的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yidier">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="黄奕弟的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黄奕弟的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Taro小程序云开发（上）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/Taro%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time datetime="2020-03-30T15:01:05.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/Taro%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/">Taro小程序云开发（上）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Taro-介绍"><a href="#Taro-介绍" class="headerlink" title="Taro 介绍"></a>Taro 介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Taro</strong>  是一套遵循  <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>  语法规范的  <strong>多端开发</strong>  解决方案。</p>
<p>现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。</p>
<p>使用  <strong>Taro</strong>，我们可以只书写一套代码，再通过  <strong>Taro</strong>  的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h4 id="React-语法风格"><a href="#React-语法风格" class="headerlink" title="React 语法风格"></a>React 语法风格</h4><p><strong>Taro</strong>  遵循  <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>  语法规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用  <a href="http://taro-docs.jd.com/taro/docs/jsx.html" target="_blank" rel="noopener">JSX 语法</a>，让代码具有更丰富的表现力，使用  <strong>Taro</strong>  进行开发可以获得和 React 一致的开发体验。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Taro 项目基于 node，请确保已具备较新的 node 环境（&gt;=8.0.0），推荐使用 node 版本管理工具  <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>  来管理 node，这样不仅可以很方便地切换 node 版本，而且全局安装时候也不用加 sudo 了。</p>
<p>首先，你需要使用 npm 或者 yarn 全局安装<code>@tarojs/cli</code>，或者直接使用<a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" target="_blank" rel="noopener">npx</a>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 npm 安装 CLI</span><br><span class="line">$ npm install -g @tarojs/cli</span><br><span class="line"># OR 使用 yarn 安装 CLI</span><br><span class="line">$ yarn global add @tarojs/cli</span><br><span class="line"># OR 安装了 cnpm，使用 cnpm 安装 CLI</span><br><span class="line">$ cnpm install -g @tarojs/cli</span><br></pre></td></tr></table></figure>

<h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>使用命令创建模板项目</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ taro init myApp</span><br></pre></td></tr></table></figure>

<p>npm 5.2+ 也可在不全局安装的情况下使用 npx 创建模板项目</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx @tarojs/cli init myApp</span><br></pre></td></tr></table></figure>

<p>选择wxcloud  / 小程序云开发模板</p>
<p><img src="%5Bhttps://raw.githubusercontent.com/eddieyd/eddieyd.github.io/master/images/2020-03-30__1.jpg%5D" alt="1"></p>
<p>模板目录结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── client                                  小程序端目录</span><br><span class="line">│   ├── config                              配置目录</span><br><span class="line">│   │   ├── dev.js                          开发时配置</span><br><span class="line">│   │   ├── index.js                        默认配置</span><br><span class="line">│   │   └── prod.js                         打包时配置</span><br><span class="line">│   ├── dist                                编译结果目录</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── src                                 源码目录</span><br><span class="line">│   │   ├── app.scss                        项目总通用样式</span><br><span class="line">│   │   ├── app.js                          项目入口文件</span><br><span class="line">│   │   ├── components                      组件文件目录</span><br><span class="line">│   │   │   └── login                       login 组件目录</span><br><span class="line">│   │   │       └── index.weapp.js          login 组件逻辑</span><br><span class="line">│   │   └── pages                           页面文件目录</span><br><span class="line">│   │       └── index                       index 页面目录</span><br><span class="line">│   │           ├── index.scss              index 页面逻辑</span><br><span class="line">│   │           └── index.js                index 页面样式</span><br><span class="line">├── cloud                                   服务端目录</span><br><span class="line">│   └── functions                           云函数目录</span><br><span class="line">│       └── login                           login 云函数</span><br><span class="line">│           ├── index.js                    login 函数逻辑</span><br><span class="line">│           └── package.json</span><br><span class="line">└── project.config.json                     小程序项目配置</span><br></pre></td></tr></table></figure>

<p>使用要点</p>
<ol>
<li><p>开发时，进入 client 目录，在此目录下运行相关编译预览或打包命令</p>
</li>
<li><p>使用微信开发者工具调试项目，请将项目 <strong>整个文件夹</strong> 作为运行目录。 注意： 不是 client 中生成的 dist 文件夹</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/30/Taro%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="ck8emvcn70000rnqxcoxh74c7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈Debounce 与 Throttle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E6%B5%85%E8%B0%88Debounce%20%E4%B8%8E%20Throttle/" class="article-date">
  <time datetime="2020-03-22T12:55:10.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E6%B5%85%E8%B0%88Debounce%20%E4%B8%8E%20Throttle/">浅谈Debounce 与 Throttle</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>debounce  与  <code>throttle</code>  是开发中常用的高阶函数，作用都是为了防止函数被高频调用，换句话说就是，用来控制某个函数在一定时间内执行多少次。  </p>
<p><strong>使用场景</strong>：</p>
<p>比如绑定响应鼠标移动、窗口大小调整、滚屏等事件时，绑定的函数触发的频率会很频繁。若稍处理函数微复杂，需要较多的运算执行时间和资源，往往会出现延迟，甚至导致假死或者卡顿感。为了优化性能，这时就很有必要使用<code>debounce</code>或<code>throttle</code>了。  </p>
<p>由于<code>debounce</code>与<code>throttle</code>两个函数的作用相同，且调用方法和参数都相同，这让我们很容易弄混。今天就来谈谈<code>debounce</code>和<code>throttle</code>的用法与差异。</p>
<p>下面先看看<code>lodash</code>中的<code>_.debounce()</code>与<code>_.throttle()</code>。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;]) _.throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<p><strong>1. debounce</strong></p>
<p>语法：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<p>debounce函数通常称为防抖动函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 fn 方法  </p>
<p><strong>简单实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, options</span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">    wait = wait || <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timerId;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timerId) &#123;   </span><br><span class="line"></span><br><span class="line">            clearTimeout(timerId);</span><br><span class="line"></span><br><span class="line">            timerId = <span class="literal">null</span>;   </span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        timerId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">            fn();     </span><br><span class="line"></span><br><span class="line">      &#125;, wait);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们在<code>debounce</code>函数中定义了一个<code>debounced()</code>函数，内部定义了一个定时器，每当触发事件时，都会重置定时器，也就是说，当事件被执行时，并不会立刻执行fn，而是等待一定时间(wait)后才会执行。如果wait过后，函数没有再次被执行，就会处理最后一个fn。</p>
<p>注意：即使还有0.01秒就到指定时间，如果这时又执行了一次函数，那么之前的定时器就会被取消，需要重新等待到达指定时间。  </p>
<p><strong>2. Throttle</strong></p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<p>节流函数，在 wait 秒内最多执行 fn 一次的函数。  </p>
<p>与<code>deboucne</code>不同的是，<code>throttle</code>会有一个阀值，当到达阀值时，fn一定会执行。  </p>
<p><strong>简单实现</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, options</span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">    wait = wait || <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timerId, lastTime = <span class="number">0</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= lastTime + wait) &#123;   </span><br><span class="line"></span><br><span class="line">            fn();   </span><br><span class="line"></span><br><span class="line">            lastTime = currentTime;   </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timerId) &#123;   </span><br><span class="line"></span><br><span class="line">                clearTimeout(timerId);   </span><br><span class="line"></span><br><span class="line">                timerId = <span class="literal">null</span>;   </span><br><span class="line"></span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            timerId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line"></span><br><span class="line">                fn()   </span><br><span class="line"></span><br><span class="line">            &#125;, wait);   </span><br><span class="line"></span><br><span class="line">       &#125;   </span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">著作权归作者所有。</span><br><span class="line">商业转载请联系作者获得授权,非商业转载请注明出处。</span><br><span class="line">原文: https:<span class="comment">//laixiazheteng.com/article/page/id/4qrB9JeihTKD © ghmagical.com</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们会记录每次函数被实际调用的时间，如果下次调用时，还没到达阀值，就会继续等待，直到到达阀值，就会调用最后一次函数。  </p>
<p><strong>完整实例</strong></p>
<p><a href="https://codepen.io/TGCode/pen/jZodyM" target="_blank" rel="noopener">https://codepen.io/TGCode/pen/jZodyM</a>  </p>
<p><strong>总结</strong>  </p>
<ul>
<li><code>debounce</code>：将触发频繁的事件合并成一次执行。<code>debounce</code>适用于诸如input事件，当用户输入时需要响应ajax请求，多次input只响应一次回调方法</li>
<li><code>throttle</code>： 设置一个阀值，在阀值内，将触发的事件合并成一次执行；且当到达阀值，必定执行一次事件。<code>throttle</code>适用于resize或者鼠标移动事件，防止浏览器频繁响应事件，严重拉低性能</li>
</ul>
<p>参考文章</p>
<ul>
<li><p><a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="noopener">http://benalman.com/projects/jquery-throttle-debounce-plugin/</a>  </p>
</li>
<li><p><a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/" target="_blank" rel="noopener">https://css-tricks.com/the-difference-between-throttling-and-debouncing/</a></p>
</li>
</ul>
<p><a href="https://laixiazheteng.com/article/page/id/4qrB9JeihTKD" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/22/%E6%B5%85%E8%B0%88Debounce%20%E4%B8%8E%20Throttle/" data-id="ck8333veh0000fjqx7axfgbhq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端之JS的线程(最易懂)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E5%89%8D%E7%AB%AF%E4%B9%8BJS%E7%9A%84%E7%BA%BF%E7%A8%8B(%E6%9C%80%E6%98%93%E6%87%82)/" class="article-date">
  <time datetime="2020-03-22T12:34:47.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E5%89%8D%E7%AB%AF%E4%B9%8BJS%E7%9A%84%E7%BA%BF%E7%A8%8B(%E6%9C%80%E6%98%93%E6%87%82)/">前端之JS的线程(最易懂)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>很多文章在介绍线程以及线程之间的关系，都存在着脱节的现象。还有的文章过于广大，涉及到了内核，本文希望以通俗易懂的话去描述晦涩的词语，可能会和实际有一丢丢的出入，但是更易理解。</p>
<p>我们都知道JS是单线程的，即js的代码只能在一个线程上运行，也就说，js同时只能执行一个js任务，但是为什么要这样呢？这与浏览器的用途有关，JS的主要用途是与用户互动和操作DOM。设想一段JS代码，分发到两个并行互不相关的线程上运行，一个线程在DOM上添加内容，另一个线程在删除DOM，那么会发生什么？以哪个为准？所以为了避免复杂性，JS从一开始就是单线程的，以后也不会变。</p>
<p>这里我们已经知道了，一段JS代码只能在一个线程从上到下的执行，但是我们遇到setTimeout或者ajax异步时，也没有等待啊，往下看。</p>
<h2 id="2-浏览器"><a href="#2-浏览器" class="headerlink" title="2. 浏览器"></a>2. 浏览器</h2><p>既然JS是单线程的，那么诸如onclick回调，setTimeout，Ajax这些都是怎么实现的呢？是因为浏览器或node（宿主环境）是多线程的，即浏览器搞了几个其他线程去辅助JS线程的运行。</p>
<p>浏览器有很多线程，例如：</p>
<ol>
<li><p>GUI 渲染线程</p>
</li>
<li><p>JS 引擎线程</p>
</li>
<li><p>定时器触发线程 (setTimeout)</p>
</li>
<li><p>浏览器事件线程 (onclick)</p>
</li>
<li><p>http 异步线程</p>
</li>
<li><p>EventLoop轮询处理线程</p>
<p>…</p>
</li>
</ol>
<p>其中，1、2、4为常驻线程</p>
<p>接下来，我们对这些线程进行分类。</p>
<h2 id="3-线程与进程"><a href="#3-线程与进程" class="headerlink" title="3. 线程与进程"></a>3. 线程与进程</h2><p>什么是进程？</p>
<p>我们可以在电脑的任务管理器中查看到正在运行的进程，可以认为一个进程就是在运行一个程序，比如用浏览器打开一个网页，这就是开启了一个进程。但是比如打开3个网页，那么就开启了3个进程，我们这里只研究打开一个网页即一个进程。</p>
<p>一个<strong>进程</strong>的运行，当然需要很多个<strong>线程</strong>互相配合，比如打开QQ的这个进程，可能同时有接收消息线程、传输文件线程、检测安全线程……所以一个网页能够正常的运行并和用户交互，也需要很多个进程之间相互配合，而其主要的一些线程，刚才在上面已经列出来了，分类：</p>
<p>类别A：GUI 渲染线程</p>
<p>类别B：JS 引擎线程</p>
<p>类别C：EventLoop轮询处理线程</p>
<p>类别D：其他线程，有 定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)等等。</p>
<p><strong>注意：</strong>  类别A和类别B是互斥的，原因不用说了，不知道的看我上一篇文章。所以我们下面的讨论，就不涉及类别A了，只讨论类别B、C、D之间的关系。</p>
<h4 id="类别B："><a href="#类别B：" class="headerlink" title="类别B："></a>类别B：</h4><p>JS 引擎线程，我们把它称为<strong>主线程</strong>，它是干嘛的？即运行JS代码的那个线程（不包括异步的那些代码），比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 var a &#x3D; 2;</span><br><span class="line">2 setTimeout()</span><br><span class="line">3 ajax()</span><br><span class="line">4 console.log()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第1、4行代码是同步代码，直接在主线程中运行；第2、3行代码交给其他线程运行。</p>
<p>主线程运行JS代码时，会生成个<strong>执行栈</strong>，可以处理函数的嵌套，通过出栈进栈这样，这里不做过多介绍，很多文章。</p>
<h4 id="消息队列（任务队列）"><a href="#消息队列（任务队列）" class="headerlink" title="消息队列（任务队列）"></a>消息队列（任务队列）</h4><p>可以理解为一个静态的队列存储结构，非线程，只做存储，里面存的是一堆异步成功后的回调函数<strong>字符串</strong>，肯定是先成功的异步的回调函数在队列的前面，后成功的在后面。</p>
<p>注意：是异步成功后，才把其回调函数扔进队列中，而不是一开始就把所有异步的回调函数扔进队列。比如setTimeout 3秒后执行一个函数，那么这个函数是在3秒后才进队列的。</p>
<h4 id="类别D："><a href="#类别D：" class="headerlink" title="类别D："></a>类别D：</h4><p>定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)</p>
<p>主线程执行JS代码时，碰到异步代码，就把它丢给各自相对应的线程去执行，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 var a &#x3D; 2;</span><br><span class="line">2 setTimeout(fun A)</span><br><span class="line">3 ajax(fun B)</span><br><span class="line">4 console.log()</span><br><span class="line">5 dom.onclick(func C)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>主线程在运行这段代码时，碰到2 setTimeout(fun A)，把这行代码交给<strong>定时器触发线程</strong>去执行</p>
<p>碰到3 ajax(fun B)，把这行代码交给<strong>http 异步线程</strong>去执行</p>
<p>碰到5 dom.onclick(func C) ，把这行代码交给<strong>浏览器事件线程</strong>去执行</p>
<p><strong>注意：</strong>  这几个异步代码的回调函数fun A，fun B，fun C，各自的线程都会保存着的，因为需要在未来的某个时候，将回调函数交给主线程去执行啊。。。</p>
<p>所以，这几个线程主要干两件事：</p>
<ol>
<li>执行主线程扔过来的异步代码，并执行代码</li>
<li>保存回调函数，在未来的某个时刻，通知<strong>EventLoop轮询处理线程</strong>过来取相应的回调函数然后执行（下面会讲）</li>
</ol>
<h4 id="类别C："><a href="#类别C：" class="headerlink" title="类别C："></a>类别C：</h4><p>EventLoop轮询处理线程</p>
<p>上面我们已经知道了，有3个东西</p>
<ol>
<li>主线程，处理同步代码</li>
<li>类别D的几个异步线程，处理异步代码</li>
<li>消息队列，存储着异步成功后的回调函数，一个静态存储结构</li>
</ol>
<p>这里再对消息队列说一下，其作用就是存放着未来要执行的回调函数，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;, 2000)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 3000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在一开始，消息队列是空的，在2秒后，一个 () =&gt; { console.log(1) } 的函数进入队列，在3秒后，一个 () =&gt; { console.log(2) }的函数进入队列，此时队列里有两个元素，主线程从队列头中挨个取出并执行。</p>
<p>到这里我们就知道了，这3个东西大概的作用、关系和流程，但是，它们3个互相怎么交流的？这需要一个中介去专门去沟通它们3个，而这个中介，就是<strong>EventLoop轮询处理线程</strong></p>
<p>既然叫轮询了，那么肯定是不断的循环的去交流和沟通</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/4/16818b1c01ca7df3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图画的有点丑，但是大概是这个意思，从主线程那里顺时针的看。</p>
<p>注意整个的流程是循环往复的。</p>
<p>注意只有主线程的同步代码都执行完了，才会去队列里看看还有啥要执行的没</p>
<h4 id="小区别"><a href="#小区别" class="headerlink" title="小区别"></a>小区别</h4><p>在异步线程类别D那里，还有一些小区别：</p>
<p>主线程把setTimeout、ajax、dom.onclick分别给三个线程，他们之间有些不同</p>
<ul>
<li><p>对于setTimeout代码，定时器触发线程在接收到代码时就开始计时，<strong>时间到了将回调函数扔进队列</strong>。</p>
</li>
<li><p>对于ajax代码，http 异步线程立即发起http请求，<strong>请求成功后将回调函数扔进队列</strong>。</p>
</li>
<li><p>对于dom.onclick，浏览器事件线程会先监听dom，直到<strong>dom被点击了，才将回调函数扔进队列</strong>。</p>
</li>
</ul>
<h2 id="4-总体实例"><a href="#4-总体实例" class="headerlink" title="4. 总体实例"></a>4. 总体实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 111;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(222)</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">fetch(url)  &#x2F;&#x2F; 假设该http请求花了3秒钟</span><br><span class="line">.then(function() &#123;</span><br><span class="line">    console.log(333)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">dom.onclick &#x3D; function() &#123;  &#x2F;&#x2F; 假设用户在4秒钟时点击了dom</span><br><span class="line">    console.log(444)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(555)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果</span><br><span class="line">555</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">444</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="步骤1："><a href="#步骤1：" class="headerlink" title="步骤1："></a>步骤1：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b7332de955ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>主线程只执行了var a = 111;和console.log(555)两行代码，其他的代码分别交给了其他三个线程，因为其他线程需要2、3、4秒钟才成功并回调，所以在2秒之前，主线程一直在空闲，不断的探查队列是否不为空。</p>
<p>此时主线程里其实已经是空的了（因为执行完那两行代码了）</p>
<h4 id="步骤2："><a href="#步骤2：" class="headerlink" title="步骤2："></a>步骤2：</h4><p>2秒钟之后，setTimeout成功了</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b7034ad6ad14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="步骤3："><a href="#步骤3：" class="headerlink" title="步骤3："></a>步骤3：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b77b0839fc10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="步骤4："><a href="#步骤4：" class="headerlink" title="步骤4："></a>步骤4：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b7a5e48665e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>图里的队列里都只有一个回调函数，实际上有很多个回调函数，如果主线程里执行的代码复杂需要很长时间，这时队列里的函数们就排着，等着主线程啥时执行完，再来队列里取</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b7da0f89d552?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>所以从这里能看出来，对于setTimeout，setInterval的定时，不一定完全按照设想的时间的，因为主线程里的代码可能复杂到执行很久，所以会发生你定时3秒后执行，实际上是3.5秒后执行（主线程花费了0.5秒）</p>
<p>之后我会再写如何解决定时误差的内容。。。</p>
<h3 id="借两个经典的图"><a href="#借两个经典的图" class="headerlink" title="借两个经典的图"></a>借两个经典的图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/4/16818e049fd1a479?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/4/16818e06c0ce968a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><a href="https://juejin.im/post/5c2ec3b66fb9a049eb3c1012" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/22/%E5%89%8D%E7%AB%AF%E4%B9%8BJS%E7%9A%84%E7%BA%BF%E7%A8%8B(%E6%9C%80%E6%98%93%E6%87%82)/" data-id="ck8333vfk0001fjqx93swdcjf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/30/Taro%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89/">Taro小程序云开发（上）</a>
          </li>
        
          <li>
            <a href="/2020/03/22/%E6%B5%85%E8%B0%88Debounce%20%E4%B8%8E%20Throttle/">浅谈Debounce 与 Throttle</a>
          </li>
        
          <li>
            <a href="/2020/03/22/%E5%89%8D%E7%AB%AF%E4%B9%8BJS%E7%9A%84%E7%BA%BF%E7%A8%8B(%E6%9C%80%E6%98%93%E6%87%82)/">前端之JS的线程(最易懂)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 yidier<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>